public class leetcode29{
    //给定一个数组A包含N个元素，下标范围[0..N - 1]。一个前缀后缀集是满足这样条件的下标对(P,S)， 
    //0<= P,S < N 满足数组元素A[0..P]的值也在A[S..N - 1]的值中出现，
    //并且A[S..N - 1]中的值也再A[0..P]中出现。换句话说除去重复的值，
    //前缀的集合A[0..P]与后缀集合A[S..N - 1]包含完全相同的值。求这样的下标对数，
    //如果结果大于1000000000,返回1000000000。
    //数据范围N [1..40000]，数组元素都是整数，范围[-10^9, +10^9]。
    //要求复杂度 时间O(Nlog(N)),空间O(N)。
    //题目不难，我们维护两个位置i和j，满足对于前缀A[0..i]和A[j..N - 1]是满足条件的，
    //并且A[i + 1]不在A[0..i]中出现，A[j - 1]不在A[j..N - 1]中出现（*）。
    //起初i = -1, j = N，这时前缀后缀都是空集。 
    //我们记录下每个元素第一次出现的位置first,和最后一次出现的位置last。
    //我们从上次的i,j出发试图在次找到一个满足条件的下标对，
    //这样的下标对(i',j')满足 min{last[A[0..i']} >= j' ,  max{first[A[j'..N - 1]} <= i' ， 
    //我们沿着i滑行i'，滑到一个位置，决定j‘是否要变化，同时j'的变化会影响i'的变化，直到双方都满足条件位置。
    //然后我们这样的i'可以继续向前滑行到I，保证前缀集合不变。j'继续滑行到J，保证后缀集合不变，
    //这时(J - j +1 ) * (I - i + 1)个pair都满足要求，同时我们的I,J也是满足条件（*）的值。
    // 这就维护了循环不变式。
    //时间复杂度，滑行是O(N)，关键记录第一次和最后一次出现的位置一个map，N个元素需要O(NlogN)的时间，
    //如果数据范围小，可以多用个数组记录，达到O(1)。
    //空间，就是记录每个值第一次和最后一次出现的值。
    public class Beryllium{
        int solution(vector<int> &A) {  
            // write your code here...  
            map<int,int> first,last;  
            int i,j,x,y,n = A.size(),p,answer = 0;  
            for (i = 0; i < n; ++i) {  
                last[A[i]] = i;  
            }  
            for (i = n - 1; i >= 0; --i) {  
                first[A[i]] = i;  
            }  
            for (i = -1, j = n;;) {  
                for (p = last[A[++i]]; j > p;) {  
                    for (x = first[A[--j]]; i < x;p = min(p, last[A[++i]]))  
                    ;  
                }  
                for (x = i + 1; (x < n) && (last[A[x]] >= j); ++x)  
                ;  
                for (y = j - 1; (y >= 0) && (first[A[y]] <=i); --y)  
                ;  
                if ((answer += (x - i) * (j - y)) > 1000000000) {  
                    return 1000000000;  
                }  
                if ((x >= n) || (y < 0)) {  
                    break;  
                }  
                i = x - 1;  
                j = y + 1;  
            }  
                    
            return answer;  
        
        }  
    }
}