public class leetcode19{
    //题目： 像最大直方图一样给定一个数组是每个单位长度上的高度，求至少几个矩形可以拼出这个形状。
    //  例如：给出的数组
    //H[0] = 8    H[1] = 8    H[2] = 5    
    //H[3] = 7    H[4] = 9    H[5] = 8    
    //H[6] = 7    H[7] = 4    H[8] = 8   


    //因为可以用如上的7块可以达到要求。

    //输入范围： n [1..10^5] 数组种每个元素 [1..10^9]
    //要求复杂度 时间 空间都为O(n)。
    //分析： 这个问题实际上叫做skyline problem。初步想想挺复杂，其实一个贪心足以搞定。
    //我个人觉得直方图最大矩形的那个题的思想很重要，它的思想可以解决很多问题，而且是O(n)的。
    //我们按最大矩形的方法来想，贪心： 对每个块，考虑它左边的块，直到某一块不比它高。
    //这中间所有块都比它高，我们可以把这些块按照新块的高度设置一个矩形……矩形个数决定于最先那个块是比它矮，
    //还是和她一样高。这样贪心的话，我们的矩形尽可能长，而且产生一个新块的时候无论如何我们都可能增加一个矩形，
    //把这个矩形和左边的连起来还可能少一个矩形，所以不严格的证明，贪心是正确地。 
    public class Sigma2012{
        int solution(const vector<int> &H) {  
            // write your code here...  
            vector<int> v;  
            int i, answer;  
            for (i = answer = 0; i < H.size(); ++i) {  
                while ((!v.empty()) && (v.back() > H[i])) {  
                    v.pop_back();  
                }  
                if ((v.empty()) || (v.back() < H[i])) {  
                    ++answer;  
                    v.push_back(H[i]);  
                }  
            }  
            return answer;  
                    
        }  
    }
}